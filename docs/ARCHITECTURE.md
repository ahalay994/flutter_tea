# Архитектурная документация проекта "Tea App"

## Общая архитектура

Проект "Tea App" реализует клиент-серверную архитектуру с использованием Flutter для мобильного клиента и внешнего API для серверной части.

### Уровни архитектуры:

```
┌─────────────────────────────────────┐
│            Presentation             │
│      (screens, widgets, UI)        │
├─────────────────────────────────────┤
│         Business Logic              │
│     (controllers, services)         │
├─────────────────────────────────────┤
│              Data                   │
│    (API clients, local database)    │
└─────────────────────────────────────┘
```

## Подробное описание слоев

### 1. Слой представления (Presentation Layer)

**Расположение:** `lib/screens/`, `lib/widgets/`

**Назначение:**
- Отображение пользовательского интерфейса
- Обработка пользовательских действий
- Визуализация данных из бизнес-логики

**Компоненты:**
- `HomeScreen` - главный экран с каталогом чаёв
- `AddScreen` - экран добавления нового чая
- `DetailsScreen` - экран просмотра деталей чая
- `TeaFilterDrawer` - боковое меню с фильтрами
- `TeaCard` - карточка отдельного чая
- `AnimatedLoader` - анимированный индикатор загрузки

**Паттерны:**
- Используется ConsumerWidget для взаимодействия с Riverpod
- Виджеты разбиты на основные экраны и вспомогательные компоненты
- Используются состоятельные и безсостоятельные виджеты

### 2. Слой бизнес-логики (Business Logic Layer)

**Расположение:** `lib/controllers/`, `lib/services/`

**Назначение:**
- Управление бизнес-логикой приложения
- Координация между различными компонентами
- Обработка сложных операций (фильтрация, синхронизация)

**Компоненты:**
- `TeaController` - основной контроллер приложения
- `LocalDatabaseService` - работа с локальной базой данных
- `NetworkService` - управление сетевыми соединениями
- `ImageCacheService` - кеширование изображений

**Паттерны:**
- MVVM (Model-View-ViewModel)
- Repository Pattern для работы с данными
- State Management через Riverpod

### 3. Слой данных (Data Layer)

**Расположение:** `lib/api/`, `lib/models/`

**Назначение:**
- Взаимодействие с внешними API
- Хранение данных в локальной базе
- Преобразование данных между форматами

**Компоненты:**
- `TeaApi`, `CountryApi`, `TypeApi` и др. - API клиенты
- `TeaModel` - модель данных чая
- `LocalDatabaseService` - локальная база данных SQLite

## Управление состоянием

### Riverpod как система управления состоянием

**Преимущества:**
- Независимость от контекста виджета
- Автоматическая очистка ресурсов
- Мощная система зависимостей
- Тестопригодность

**Основные провайдеры:**
- `StateNotifierProvider` - для изменяемого состояния (фильтры)
- `FutureProvider` - для асинхронных данных (список чаёв)
- `StreamProvider` - для данных в реальном времени (статус подключения)

**Пример архитектуры провайдеров:**
```
TeaController (Provider)
├── teaListProvider (FutureProvider)
├── filteredTeaListProvider (FutureProvider)
├── filterParamsProvider (StateNotifierProvider)
├── filterTypeProvider (StateNotifierProvider)
└── connectionStatusProvider (StreamProvider)
```

## Система фильтрации

### Архитектура фильтрации

**Компоненты:**
- `FilterParamsNotifier` - состояние параметров фильтрации
- `TeaFilterDrawer` - интерфейс мультиселект фильтров
- `TeaFacetFilterDrawer` - интерфейс фасетных фильтров
- `getFilteredTeasWithNames()` - метод фильтрации в базе данных

**Механизм работы:**
1. Пользователь выбирает фильтры через drawer
2. Параметры сохраняются в `filterParamsProvider`
3. При изменении параметров вызывается перезагрузка данных
4. В зависимости от параметров используется соответствующий метод загрузки

## Оффлайн режим

### Архитектура оффлайн режима

**Компоненты:**
- `NetworkService` - определение статуса подключения
- `LocalDatabaseService` - хранение данных локально
- `TeaController` - логика переключения между режимами

**Механизм работы:**
1. Проверяется статус подключения
2. При наличии подключения данные берутся из API
3. При отсутствии подключения данные берутся из локальной базы
4. При восстановлении соединения происходит синхронизация данных

## Пагинация и бесконечный скролл

### Архитектура пагинации

**Компоненты:**
- `_scrollListener()` - слушатель скролла
- `_loadMore()` - загрузка следующей страницы
- `PaginationResult<T>` - результат пагинации

**Механизм работы:**
1. При достижении конца списка срабатывает слушатель
2. Загружается следующая страница данных
3. Данные добавляются к существующему списку

## Управление изображениями

### Архитектура работы с изображениями

**Компоненты:**
- `ImageCacheService` - кеширование изображений
- `cached_network_image` - отображение с кешированием
- `ImagePicker` - выбор изображений

**Механизм работы:**
1. Изображения загружаются через HTTP
2. Кешируются в локальное хранилище
3. Отображаются с индикаторами загрузки

## Обработка ошибок

### Стратегия обработки ошибок

**Компоненты:**
- `AppLogger` - централизованное логирование
- `showErrorDialog()` - отображение сообщений об ошибках
- `try-catch` блоки в асинхронных операциях

**Механизм работы:**
1. Ошибки перехватываются на уровне API
2. Логируются через AppLogger
3. Отображаются пользователю в виде диалогов
4. При необходимости происходит переключение в оффлайн режим

## Масштабируемость и поддержка

### Принципы проектирования

**Разделение ответственности:**
- Каждый файл имеет одну основную цель
- Методы не превышают разумного размера
- Четкое разделение на уровни архитектуры

**Тестируемость:**
- Четкое разделение на слои
- Зависимости инвертированы через интерфейсы
- Легко заменяемые компоненты

**Расширяемость:**
- Модульная архитектура
- Возможность добавления новых типов фильтров
- Поддержка новых типов данных